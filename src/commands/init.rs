use anyhow::{bail, Context, Result};
use colored::Colorize;
use std::fs;
use std::path::Path;
use tera::{Context as TeraContext, Tera};

const PROJECT_TOML_TEMPLATE: &str = r#"name = "{{ name }}"
version = "0.1.0"
type = "{{ project_type }}"
language = "{{ language }}"
authors = []

[sources]
dirs = ["src"]

[includes]
dirs = ["include"]

[build]
flags = []
optimization = "2"

[deps]

[dev-deps]

[profile.dev]
opt_level = "0"
debug = true
lto = false
strip = false
flags = ["-Wall", "-Wextra", "-g"]

[profile.release]
opt_level = "3"
debug = false
lto = true
strip = true
flags = ["-Wall", "-Wextra", "-O3", "-DNDEBUG"]

[features]
# Define your features here
# example = ["dep:some-package"]

[scripts]
# Custom build scripts
# prebuild = "echo 'Starting build'"
# postbuild = "echo 'Build complete'"

{% if is_lib %}
[tests]
dirs = ["tests"]
harness = true
{% endif %}
"#;

const MAIN_C_TEMPLATE: &str = r#"#include <stdio.h>

int main(void) {
    printf("Hello from {{ name }}!\n");
    return 0;
}
"#;

const MAIN_CPP_TEMPLATE: &str = r#"#include <iostream>

int main() {
    std::cout << "Hello from {{ name }}!" << std::endl;
    return 0;
}
"#;

const LIB_C_TEMPLATE: &str = r#"#include "{{ name }}.h"

void {{ name }}_hello(void) {
    printf("Hello from {{ name }} library!\n");
}

int {{ name }}_add(int a, int b) {
    return a + b;
}
"#;

const LIB_H_TEMPLATE: &str = r#"#ifndef {{ name_upper }}_H
#define {{ name_upper }}_H

#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

void {{ name }}_hello(void);
int {{ name }}_add(int a, int b);

#ifdef __cplusplus
}
#endif

#endif // {{ name_upper }}_H
"#;

const LIB_CPP_TEMPLATE: &str = r#"#include "{{ name }}.hpp"
#include <iostream>

namespace {{ name }} {

void hello() {
    std::cout << "Hello from {{ name }} library!" << std::endl;
}

int add(int a, int b) {
    return a + b;
}

} // namespace {{ name }}
"#;

const LIB_HPP_TEMPLATE: &str = r#"#ifndef {{ name_upper }}_HPP
#define {{ name_upper }}_HPP

namespace {{ name }} {

void hello();
int add(int a, int b);

} // namespace {{ name }}

#endif // {{ name_upper }}_HPP
"#;

const TEST_TEMPLATE: &str = r#"#include <assert.h>
#include <stdio.h>
#include "{{ name }}.{{ header_ext }}"

int main(void) {
    printf("Running {{ name }} tests...\n");
    
    {% if is_cpp %}
    assert({{ name }}::add(2, 2) == 4);
    {% else %}
    assert({{ name }}_add(2, 2) == 4);
    {% endif %}
    
    printf("All tests passed!\n");
    return 0;
}
"#;

const GITIGNORE_TEMPLATE: &str = r#"# Build artifacts
/target
/.build
/build
compile_commands.json

# vcpkg
/vcpkg_installed

# Lock file
project.lock

# IDE
.vscode/
.idea/
.clangd/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Compiled files
*.o
*.obj
*.a
*.lib
*.so
*.dll
*.dylib
*.exe
"#;

const README_TEMPLATE: &str = r#"# {{ name }}

{{ description }}

## Features

- Feature 1
- Feature 2

## Building

```bash
# Development build
zora build

# Release build
zora build --release

# With specific features
zora build --features feature1,feature2
```

## Running

```bash
zora run
```

## Testing

```bash
zora test
```

## Dependencies

Add dependencies:

```bash
zora add <package-name>
```

## License

[LICENSE] - Add your license here
"#;

const ZORA_LOCK_TEMPLATE: &str = r#"# This file is automatically generated by Zora.
# Do not edit manually.

version = 1

[packages]
"#;

pub fn run(name_opt: Option<String>, cpp: bool, lib: bool) -> Result<()> {
    let cwd = std::env::current_dir().context("failed to get current directory")?;
    let project_name = match name_opt {
        Some(n) => n,
        None => cwd
            .file_name()
            .and_then(|s| s.to_str())
            .map(|s| s.to_string())
            .unwrap_or_else(|| "zora-project".to_string()),
    };

    if Path::new("project.toml").exists() {
        bail!("project.toml already exists in this directory");
    }

    println!("{}", "Initializing project...".bright_cyan());

    // Create directories
    fs::create_dir_all("src").context("failed to create src/")?;
    fs::create_dir_all("include").context("failed to create include/")?;
    
    if lib {
        fs::create_dir_all("tests").context("failed to create tests/")?;
        fs::create_dir_all("benches").context("failed to create benches/")?;
        fs::create_dir_all("examples").context("failed to create examples/")?;
    }

    let language = if cpp { "cpp" } else { "c" };
    let project_type = if lib { "lib" } else { "exec" };
    let ext = if cpp { "cpp" } else { "c" };
    let header_ext = if cpp { "hpp" } else { "h" };

    let mut ctx = TeraContext::new();
    ctx.insert("name", &project_name);
    ctx.insert("name_upper", &project_name.to_uppercase().replace("-", "_"));
    ctx.insert("language", language);
    ctx.insert("project_type", project_type);
    ctx.insert("is_lib", &lib);
    ctx.insert("is_cpp", &cpp);
    ctx.insert("header_ext", header_ext);
    ctx.insert("description", &format!("A {} {} project", 
        if cpp { "C++" } else { "C" },
        if lib { "library" } else { "executable" }
    ));

    // Write source files
    if lib {
        let lib_src = if cpp {
            Tera::one_off(LIB_CPP_TEMPLATE, &ctx, false)?
        } else {
            Tera::one_off(LIB_C_TEMPLATE, &ctx, false)?
        };

        let lib_header = if cpp {
            Tera::one_off(LIB_HPP_TEMPLATE, &ctx, false)?
        } else {
            Tera::one_off(LIB_H_TEMPLATE, &ctx, false)?
        };

        fs::write(format!("src/{}.{}", project_name, ext), lib_src)?;
        fs::write(format!("include/{}.{}", project_name, header_ext), lib_header)?;

        // Create basic test
        let test_content = Tera::one_off(TEST_TEMPLATE, &ctx, false)?;
        fs::write(format!("tests/test_{}.{}", project_name, ext), test_content)?;

        println!("  {} {}", "Created".green(), format!("src/{}.{}", project_name, ext));
        println!("  {} {}", "Created".green(), format!("include/{}.{}", project_name, header_ext));
        println!("  {} {}", "Created".green(), format!("tests/test_{}.{}", project_name, ext));
    } else {
        let main_src = if cpp {
            Tera::one_off(MAIN_CPP_TEMPLATE, &ctx, false)?
        } else {
            Tera::one_off(MAIN_C_TEMPLATE, &ctx, false)?
        };

        fs::write(format!("src/main.{}", ext), main_src)?;
        println!("  {} {}", "Created".green(), format!("src/main.{}", ext));
    }

    // Write project.toml
    let project_toml = Tera::one_off(PROJECT_TOML_TEMPLATE, &ctx, false)?;
    fs::write("project.toml", project_toml)?;
    println!("  {} project.toml", "Created".green());

    // Write lock file
    fs::write("project.lock", ZORA_LOCK_TEMPLATE)?;
    println!("  {} project.lock", "Created".green());

    // Write .gitignore
    let gitignore = Tera::one_off(GITIGNORE_TEMPLATE, &ctx, false)?;
    fs::write(".gitignore", gitignore)?;
    println!("  {} .gitignore", "Created".green());

    // Write README
    let readme = Tera::one_off(README_TEMPLATE, &ctx, false)?;
    fs::write("README.md", readme)?;
    println!("  {} README.md", "Created".green());

    println!("\n{} Initialized {} project: {}", 
        "✓".green().bold(), 
        if lib { "library" } else { "executable" },
        project_name.bright_yellow()
    );
    
    println!("\n{}", "Next steps:".bright_cyan());
    println!("  {} zora build", "→".bright_blue());
    println!("  {} zora run", "→".bright_blue());
    if lib {
        println!("  {} zora test", "→".bright_blue());
    }

    Ok(())
}
